<!--
 * @Date: 2021-12-14 10:51:28
 * @LastEditors: kafier
 * @LastEditTime: 2021-12-14 11:05:46
-->
# 定时器

NetLib中的定时器是基于时间堆去实现的， 为了能够简化代码， NetLib中是直接使用std中的优先队列来作为定时器队列的底层

## 定时器的功能

每一个subReactor都有一个定时器， 用于处理超时请求和长时间不活跃的连接。

并采用惰性删除的方式， 时间的到来也不会唤醒线程， 而是每次循环的最后进行检查， 如果超时了再删， 因为这里对超时的要求并不会很高， 如果此时线程满， 那么检查时间队列的间隔也会很短。 如果不忙， 也给了超时请求更长的等待时间。 

## 定时器的处理逻辑

1. 优先队列不支持随机访问 
2. 即使支持， 随机删除某节点后破坏了堆的结构，需要重新建堆结构， 所以对于被设置为deleted的时间点， 会延迟到它超时或者前面的节点都被删除， 它才会被删除
   - 这样做的好处
   - 不需要遍历优先队列， 省时 
   - 给超时时间一个容忍的时间， 就是设定的超时时间是删除的下限（并不是一到超时时间就立即删除）。 如果监听的请求在超时后的下一次请求中又一次出现了， 就不用再重新申请requestData节点， 可以重复利用前面的RequestData， 减少了一次delete和一次new 的时间
3. 不会陷入死循环， 如果队列不为空，且没有到达超时时间， 那么就跳循环

---

