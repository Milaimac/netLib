<!--
 * @Date: 2021-12-09 21:02:56
 * @LastEditors: kafier
 * @LastEditTime: 2021-12-09 21:03:54
-->
[TOC]

## 多线程的异步日志库

#### 怎么实现线程安全

多线程程序需要日志库做到线程安全， 多个线程可以并发写日志， 两个线程的日志消息不会出现交织。 

**低效做法：**

- 使用一个全局mutex保护IO
- 每个线程单独写一个日志文件， 不过两种做法的高效性堪忧； 前者会造成全部线程争抢一个锁， 后者有可能让业务线程阻塞在写磁盘操作上。 

**解决办法：**

**用一个背景线程负责收集日志消息， 并且写入日志文件， 其他业务线程只管往这个“日志线程”发送日志消息，** 这称为“异步日志”



#### 异步日志在多线程服务程序是必要的

因为如果在网络IO线程或业务线程中直接往磁盘写数据的话，写操作偶尔可能阻塞长达数秒之久， 这导致请求方超时， 或者耽误发送心跳信息。 因此， 在实时业务处理流程中应该彻底避免磁盘IO， 这在使用`one loop per thread`模型的非阻塞服务端程序中尤为重要。 因为线程是复用的， 阻塞线程影响多个客户连接。 

#### 实际上日志线程的处理

需要一个“队列”来将日志前端的数据传送到后端（日志线程）， 但这个“队列”不必是现成的`BlockingQueue<std::string>	`， 不用每次产生一条日志消息都通知接收方。 

#### 通过宏定义标识 那个文件写入的日志

```cpp
#define LOG Logger(__FILE__, __LINE__).stream()
```

#### 多线程异步日志库 用来记录什么

1. 收到的每条内部消息的id
2. 收到的每条外部消息的全文
3. 发出的每条消息的全文， 每条消息都有全局唯一的id
4. 关键内部状态的变更

