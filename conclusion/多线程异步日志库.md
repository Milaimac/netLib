<!--
 * @Date: 2021-12-09 21:02:56
 * @LastEditors: kafier
 * @LastEditTime: 2021-12-14 11:05:50
-->


# 多线程的异步日志库

## 怎么实现线程安全

多线程程序需要日志库做到线程安全， 多个线程可以并发写日志， 两个线程的日志消息不会出现交织。 

**低效做法：**

- 使用一个全局mutex保护IO
- 每个线程单独写一个日志文件， 不过两种做法的高效性堪忧； 前者会造成全部线程争抢一个锁， 后者有可能让业务线程阻塞在写磁盘操作上。 

**解决办法：**

**用一个背景线程负责收集日志消息， 并且写入日志文件， 其他业务线程只管往这个“日志线程”发送日志消息，** 这称为“异步日志”



## 异步日志在多线程服务程序是必要的

因为如果在网络IO线程或业务线程中直接往磁盘写数据的话，写操作偶尔可能阻塞长达数秒之久， 这导致请求方超时， 或者耽误发送心跳信息。 因此， 在实时业务处理流程中应该彻底避免磁盘IO， 这在使用`one loop per thread`模型的非阻塞服务端程序中尤为重要。 因为线程是复用的， 阻塞线程影响多个客户连接。 

## 实际上日志线程的处理

需要一个“队列”来将日志前端的数据传送到后端（日志线程）， 但这个“队列”不必是现成的`BlockingQueue<std::string>	`， 不用每次产生一条日志消息都通知接收方。 

## 通过宏定义标识 那个文件写入的日志

```cpp
#define LOG Logger(__FILE__, __LINE__).stream()
```

## 多线程异步日志库 用来记录什么

1. 收到的每条内部消息的id
2. 收到的每条外部消息的全文
3. 发出的每条消息的全文， 每条消息都有全局唯一的id
4. 关键内部状态的变更

## 底层实现

其中日志库中底层实现是利用双缓冲技术。 

异步日志库的实现分为前端和后端。前端往后端写， 后端往磁盘写。 

这里说到的log前端是IO线程， 负责产生log， 后端是log线程， 设计了多个缓冲区， 负责收集前端产生的log， 集中往磁盘写。 这样， log写道后端是没有障碍的。 

后端是多个缓冲区构成的， 集满了或者时间一到就向文件写一次， 至于双缓冲区， 实际采用的是4个多缓冲区。 4个缓冲区分为两组， 每组一个负责主要的写操作， 另外一个防止第一个写满了没地方写。 写满或者时间到了就和另外两个交换指针， 然后把满的往文件里写。 

- 准备两块缓冲，`buffers_` 和 `bufferToWrite_`, 前端通过向`buffers_`填数据（这个位置由append 负责）， 后端负责将`bufferToWrite_`的数据写入日志文件（`LogFile output`)
- 实现细节：
  - 使用了`currentBuffer`和 `nextBuffer`是一个`FixedBuffer`， 注意`FixedBuffer`的底层容器是 `char `数组。 而`buffers_`和`bufferToWrite`是 `vector<std::unique_ptr<Buffer>> `。 通过使用`unique_ptr`来表示`buffers_`的元素是一个不能够被共享的指针。 无法复制到其他unique_ptr， 也无法值传递到函数。
  - 所以为了优化程序性能， 这里不使用拷贝，而是使用`std::move(currebuffer_)`来实现内存块（对象）的转移
- 情况考虑
  - 如果前端数据过少， 可能会出现一个buffer元素都没有填充完毕， 日志库也会执行flushInterval秒执行一次交换写入操作
  - 如果前端输入数据过多， `bufferToWrite.size() > 25`, 则会清空该缓冲的`begin()+2, end()`空间的内存， 并且报错。 因为往往日志中前几条的数据是最为重要的。 

### 优点

- 使用两个buffer 的好处就是新建日志消息的时候不必等待磁盘文件操作， 也避免每条消息触发了后端日志线程。 并且前端不是一条一条的把消息传送给后端， 而是把多个日志消息拼成一个大的buffer传送给后端。 相当于批处理数据

### 整体流程图
![无标题-2021-11-10-1620(2)](https://i.loli.net/2021/11/14/PjqbcgEhRXIWHCs.png)